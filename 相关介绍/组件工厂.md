# ComponentFactory类
#### src/libs/libserver/component_factory.h
```cpp
#pragma once
#include <string>
#include <functional>
#include <map>
#include <iostream>
#include <mutex>

// ComponentFactory模板类，用于创建组件
template<typename ...Targs>
class ComponentFactory {
public:
    // 定义工厂函数类型
    typedef std::function<IComponent*(SystemManager*, Targs...)> FactoryFunction;

    // 获取单例实例
    static ComponentFactory<Targs...>* GetInstance() {
        if (_pInstance == nullptr) {
            _pInstance = new ComponentFactory<Targs...>();
        }
        return _pInstance;
    }

    // 注册组件工厂函数
    bool Regist(const std::string& className, FactoryFunction pFunc) {
        std::lock_guard<std::mutex> guard(_lock);
        if (_map.find(className) != _map.end())
            return false;

        _map.insert(std::make_pair(className, pFunc));
        return true;
    }

    // 检查组件是否已注册
    bool IsRegisted(const std::string& className) {
        std::lock_guard<std::mutex> guard(_lock);
        return _map.find(className) != _map.end();
    }

    // 创建组件实例
    IComponent* Create(SystemManager* pSysMgr, const std::string className, Targs... args) {
        _lock.lock();
        auto iter = _map.find(className);
        if (iter == _map.end()) {
            std::cout << "ComponentFactory Create failed. can't find component. className:" << className.c_str() << std::endl;
            _lock.unlock();
            return nullptr;
        }
        auto fun = iter->second;
        _lock.unlock();

        return fun(pSysMgr, std::forward<Targs>(args)...);
    }

private:
    static ComponentFactory<Targs...>* _pInstance;  // 单例实例指针
    std::map<std::string, FactoryFunction> _map;    // 存储类名与工厂函数的映射
    std::mutex _lock;  // 互斥锁，保护_map的访问
};

// 初始化静态成员变量
template<typename ...Targs>
ComponentFactory<Targs...>* ComponentFactory<Targs...>::_pInstance = nullptr;
```

### 类介绍

`ComponentFactory`是一个模板类，用于创建组件对象。它使用工厂方法模式，通过注册和创建组件实例，提供了一种灵活的、可扩展的方式来管理组件的创建。类的主要功能如下：

1. **单例模式**：类的实例通过静态方法`GetInstance`获取，确保全局只有一个实例。
2. **注册组件**：使用`Regist`方法注册组件的工厂函数，将类名与工厂函数的映射存储在一个`std::map`中。
3. **检查注册状态**：使用`IsRegisted`方法检查某个类名是否已经注册。
4. **创建组件**：使用`Create`方法，根据类名和参数创建组件实例。如果类名未注册，则返回`nullptr`并输出错误信息。

该类通过使用`std::function`和可变参数模板，可以灵活地处理不同类型和数量的构造参数。同时，使用`std::mutex`确保线程安全。

## std::function<IComponent*(SystemManager*, Targs...)>
`std::function<IComponent*(SystemManager*, Targs...)>` 是一个模板实例化，它表示一个可以存储并调用的函数对象，这个函数对象的签名为：

- 返回类型为 `IComponent*`
- 接受的参数列表为 `(SystemManager*, Targs...)`，其中 `Targs...` 是一个模板参数包，可以代表任意数量和类型的参数。
