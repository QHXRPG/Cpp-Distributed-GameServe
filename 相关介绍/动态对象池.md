## DynamicObjectPool 类介绍
#### src/libs/libserver/object_pool.h
`DynamicObjectPool` 是一个模板类，用于高效管理对象的生命周期。它通过对象池技术减少频繁的内存分配和释放操作，从而提高系统性能。该类实现了 `IDynamicObjectPool` 接口，并采用单例模式确保全局只有一个实例。

## 主要功能：
1. **对象分配**：`MallocObject` 方法从空闲队列中获取对象，如果空闲队列为空则创建新对象。分配对象时会调用对象的 `AwakeFromPool` 方法进行初始化。
2. **对象释放**：`FreeObject` 方法将使用中的对象标记为待移除，通过缓存机制延迟释放，避免频繁的内存分配和释放。
3. **更新对象池**：`Update` 方法将待移除的对象从使用中队列移到空闲队列，并清空待移除缓存。
4. **显示对象池信息**：`Show` 方法输出对象池的当前状态，包括总对象数、空闲对象数和使用中对象数。
5. **销毁实例**：`DestroyInstance` 方法销毁单例实例，并在销毁前调用 `Update` 方法，确保所有使用中的对象都被正确回收。

## 内部实现：
- **缓存机制**：使用 `CacheRefresh` 类管理使用中的对象，通过添加缓存和移除缓存实现延迟处理。
- **线程安全**：使用 `std::mutex` 保护空闲队列和使用中队列的访问，确保多线程环境下的安全操作。
- **调试信息**：在调试模式下，统计总调用次数和对象池状态，帮助开发者了解对象池的使用情况。

## 适用场景：
- 适用于需要频繁创建和销毁对象的场景，如游戏开发中的对象管理、网络服务器中的连接管理等。
- 通过优化对象的创建和销毁过程，提高系统性能和资源利用效率。

## 空闲队列 _free 
在对象池设计中，空闲对象列表（在代码中是 `_free` 队列）起到了非常重要的作用。其主要作用包括：

1. **对象复用**：
   - 通过维护一个空闲对象列表，对象池可以重复使用已经分配的对象，而不是每次都创建新的对象。这可以显著减少内存分配和释放的开销，提高系统性能。

2. **减少内存碎片**：
   - 频繁的内存分配和释放可能导致内存碎片化。通过复用空闲对象，可以减少内存的分配和释放次数，从而减少内存碎片化的可能性。

3. **提高分配效率**：
   - 从空闲对象列表中分配对象的速度通常比调用 `new` 操作符创建新对象要快得多。因为从空闲对象列表中取对象只是简单的队列操作，而 `new` 操作符涉及到内存分配和构造函数调用。

4. **统一管理对象生命周期**：
   - 对象池可以集中管理对象的生命周期，包括对象的创建、复用和销毁。这使得内存管理更加简单和可控。

5. **减少GC压力（在有垃圾回收机制的系统中）**：
   - 如果在有垃圾回收机制的系统中频繁创建和销毁对象，会增加GC的压力。通过对象池复用对象，可以减少对象的创建和销毁，从而减轻GC的负担。

具体在代码中，空闲对象列表 `_free` 的使用流程如下：

- **对象分配 (`MallocObject`)**：
  - 当需要一个新对象时，首先检查 `_free` 列表。如果列表不为空，则取出一个空闲对象进行初始化并返回。
  - 如果 `_free` 列表为空，则调用 `CreateOne` 方法创建一个新的对象，并将其加入 `_free` 列表，然后再取出进行初始化并返回。

- **对象释放 (`FreeObject`)**：
  - 当对象不再需要使用时，通过 `FreeObject` 方法将其标记为待移除对象。
  - 在下一次 `Update` 调用时，待移除的对象会被移回 `_free` 列表，供后续复用。

- **对象池更新 (`Update`)**：
  - `Update` 方法会将标记为待移除的对象从使用中列表移回 `_free` 列表，确保这些对象可以被再次复用。

- **对象池信息显示 (`Show`)**：
  - `Show` 方法会输出对象池的状态信息，包括总对象数、空闲对象数和使用中对象数，便于监控和调试。

通过这种机制，对象池可以高效地管理对象的生命周期，提高系统性能并减少内存管理的复杂性。

## 当前正在使用的对象 _objInUse 
`_objInUse` 是一个 `CacheRefresh<T>` 类型的成员变量，用于管理当前正在使用的对象。它的主要作用是跟踪和管理那些已经从对象池中分配出去但尚未归还的对象。与 `_free` 队列配合使用，共同实现了对象池的高效管理。

具体来说，`_objInUse` 在代码中的使用方式和作用如下：

1. **对象分配 (`MallocObject`)**：
   - 当从对象池中分配一个对象时，该对象会被从 `_free` 队列中取出，并加入到 `_objInUse` 的添加缓存中。这样可以确保该对象被标记为正在使用中。
   - ```cpp
     _objInUse.GetAddCache()->push_back(pObj);
     ```

2. **对象释放 (`FreeObject`)**：
   - 当一个对象不再需要使用时，通过 `FreeObject` 方法将其标记为待移除对象。具体来说，就是将该对象添加到 `_objInUse` 的移除缓存中。
   - ```cpp
     _objInUse.GetRemoveCache()->emplace_back(dynamic_cast<T*>(pObj));
     ```

3. **对象池更新 (`Update`)**：
   - `Update` 方法会检查 `_objInUse` 是否有对象需要交换（即从添加缓存和移除缓存中进行相应的处理）。
   - 如果有需要移除的对象，会将这些对象移回 `_free` 队列，以便后续复用。
   - ```cpp
     if (_objInUse.CanSwap()) {
         freeObjs = _objInUse.Swap();
     }
     ```

4. **对象池信息显示 (`Show`)**：
   - `Show` 方法会输出对象池的状态信息，包括使用中对象的总数。这里，使用中对象总数是通过 `_objInUse` 的读取缓存、添加缓存和移除缓存的大小来计算的。
   - ```cpp
     auto count = _objInUse.GetReaderCache()->size() + _objInUse.GetAddCache()->size() + _objInUse.GetRemoveCache()->size();
     ```

### `CacheRefresh` 类的作用

`CacheRefresh` 类的主要作用是提供一个缓存机制，使得对象的添加和移除操作可以在一定程度上延迟处理，从而提高系统的并发性能和稳定性。具体来说，它通常会包含以下几个缓存：

- **读取缓存 (Reader Cache)**：
  - 用于存储当前正在使用中的对象。
  
- **添加缓存 (Add Cache)**：
  - 用于存储即将被标记为使用中的对象。比如在 `MallocObject` 中分配的新对象会加入到这个缓存中。

- **移除缓存 (Remove Cache)**：
  - 用于存储即将被标记为空闲的对象。比如在 `FreeObject` 中释放的对象会加入到这个缓存中。

通过将对象的添加和移除操作缓存起来，`CacheRefresh` 可以在适当的时机（如调用 `Swap` 方法时）进行批量处理，从而减少锁的争用，提高系统的并发性能。

### 总结

- `_free` 队列用于存储空闲对象，以便快速分配和复用。
- `_objInUse`（通过 `CacheRefresh` 实现）用于管理当前正在使用的对象，包括添加和移除的缓存机制。
- 通过 `_free` 和 `_objInUse` 的配合，对象池可以高效地管理对象的生命周期，减少内存分配和释放的开销，提高系统性能。

通过 `DynamicObjectPool` 类，可以有效地管理对象的生命周期，减少内存碎片和提高程序运行效率。