#### 代码:
```C++
#pragma once

#include "disposable.h"
#include "system.h"
#include "common.h"

#include <list>
#include <random>

// SystemManager管理着 MessageSystem 和 EntitySystem
// 协调和管理各个系统组件的生命周期和操作
class EntitySystem;
class MessageSystem;

class SystemManager : virtual public IDisposable
{
public:
    SystemManager();                                        // 构造函数
    void InitComponent();                                   // 初始化组件
    virtual void Update();                                  // 更新系统
    void Dispose() override;                                // 释放资源
    MessageSystem* GetMessageSystem() const;                // 获取MessageSystem
    EntitySystem* GetEntitySystem() const;                  // 获取EntitySystem
    std::default_random_engine* GetRandomEngine() const;    // 获取随机数引擎

protected:
    MessageSystem* _pMessageSystem;                 // 消息系统指针
    EntitySystem* _pEntitySystem;                   // 实体系统指针
    std::list<ISystem*> _systems;                   // 系统列表
    std::default_random_engine* _pRandomEngine;     // 随机数引擎指针
};
```

#### 为什么需要：
```C++
class EntitySystem;
class MessageSystem;
```

## 前向声明

`class EntitySystem;`和`class MessageSystem;`是前向声明（forward declaration），在C++中它们的作用是告诉编译器这些类存在，但不提供它们的具体定义。前向声明有以下几个主要作用：

### 1. **减少编译依赖**
前向声明可以帮助减少头文件之间的相互依赖，从而加快编译速度。如果你在一个头文件中只需要使用指向某个类的指针或引用，而不需要访问该类的具体成员，前向声明就足够了。

例如：
```cpp
class SystemManager {
public:
    SystemManager();
    void InitComponent();
    virtual void Update();
    void Dispose() override;
    MessageSystem* GetMessageSystem() const;
    EntitySystem* GetEntitySystem() const;

protected:
    MessageSystem* _pMessageSystem;
    EntitySystem* _pEntitySystem;
    // ...
};
```
在这个例子中，`SystemManager`只需要知道`MessageSystem`和`EntitySystem`的指针类型，因此前向声明就足够了，不需要包含这两个类的完整定义。

### 2. **避免循环依赖**
前向声明可以帮助避免头文件之间的循环依赖问题。如果两个类互相包含对方的头文件，会导致编译器无法处理这种循环依赖。前向声明可以打破这种循环。

例如：
```cpp
// EntitySystem.h
class SystemManager;  // 前向声明

class EntitySystem {
public:
    EntitySystem(SystemManager* pMgr);
    // ...
private:
    SystemManager* _systemManager;
};

// SystemManager.h
class EntitySystem;  // 前向声明

class SystemManager {
public:
    SystemManager();
    // ...
private:
    EntitySystem* _pEntitySystem;
};
```
通过前向声明，`EntitySystem`和`SystemManager`可以互相包含对方的指针或引用，而不需要知道对方的具体实现。

### 3. **提高代码可读性**
前向声明可以使头文件更简洁，减少不必要的包含，从而提高代码的可读性和维护性。

### 使用前向声明的注意事项
- **限制访问**：前向声明的类只能用来声明指针或引用，不能访问其成员或调用其方法。要访问具体成员或方法，必须包含该类的完整定义。
- **实现文件中包含完整定义**：在需要访问类的具体成员或方法的实现文件中，应包含该类的完整定义。

例如：
```cpp
#include "EntitySystem.h"
#include "MessageSystem.h"

SystemManager::SystemManager() {
    // 实现代码
}

MessageSystem* SystemManager::GetMessageSystem() const {
    return _pMessageSystem;
}

EntitySystem* SystemManager::GetEntitySystem() const {
    return _pEntitySystem;
}
```

通过这些方式，前向声明可以帮助你更好地组织代码，减少编译时间，避免循环依赖，提高代码的可维护性。