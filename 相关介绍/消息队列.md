# 消息队列系统详细介绍

这个消息队列系统主要由以下几个组件组成：

1. **MessageSystem**：负责管理和处理消息包。
2. **MessageSystemHelp**：提供一些辅助函数，用于创建、分发和发送消息包。
3. **MessageComponent**：定义了消息组件，负责处理具体的消息包。
4. **Packet**：消息包类，封装了消息的数据和元信息。
5. **IMessageCallBackFunction**：消息回调函数接口，具体的消息处理逻辑由实现该接口的类来完成。

### MessageSystem

`MessageSystem` 类是消息系统的核心，负责管理和处理消息包。它从 `ISystem` 继承，具备系统的基本功能。

**主要成员变量**：
- `_packet_lock`：互斥锁，用于保护消息包列表。
- `_cachePackets`：缓存交换器，用于存储待处理的消息包。
- `_systemMgr`：系统管理器指针。

**主要成员函数**：
- `MessageSystem(SystemManager* pMgr)`：构造函数，初始化系统管理器指针。
- `Dispose()`：资源释放函数，目前未实现具体逻辑。
- `AddPacketToList(Packet* pPacket)`：将消息包添加到待处理列表中。
- `Update(EntitySystem* pEntities)`：更新函数，处理所有待处理的消息包。
- `Process(Packet* pPacket, std::map<uint64, IComponent*>& lists)`：静态函数，处理具体的消息包。

### MessageSystemHelp

`MessageSystemHelp` 类提供了一些辅助函数，用于创建、分发和发送消息包。

**主要成员函数**：
- `CreatePacket(Proto::MsgId msgId, SOCKET socket)`：创建一个新的 `Packet` 对象。
- `DispatchPacket(const Proto::MsgId msgId, const SOCKET socket)`：通过 `MsgId` 和 `SOCKET` 创建并分发消息包。
- `DispatchPacket(const Proto::MsgId msgId, const SOCKET socket, google::protobuf::Message& proto)`：通过 `MsgId`、`SOCKET` 和 Protobuf 消息序列化后分发消息包。
- `SendPacket(const Proto::MsgId msgId, const SOCKET socket, google::protobuf::Message& proto)`：通过 `MsgId` 和 `SOCKET` 创建并发送消息包。
- `SendPacket(const Proto::MsgId msgId, google::protobuf::Message& proto, APP_TYPE appType, int appId = 0)`：通过 `MsgId`、Protobuf 消息、应用类型和应用 ID 创建并发送消息包。
- `DispatchPacket(Packet* packet)`：分发消息包的实现。
- `SendPacket(Packet* packet, APP_TYPE appType, int appId = 0)`：发送消息包到指定应用类型和应用 ID 的实现。
- `SendPacket(Packet* pPacket)`：发送消息包的实现。

### MessageComponent

`MessageComponent` 类继承自 `Component<MessageComponent>` 和 `IAwakeFromPoolSystem<IMessageCallBackFunction*>`，是消息系统的具体组件，负责处理消息包。

**主要成员变量**：
- `_pCallBackFuns`：消息回调函数指针。

**主要成员函数**：
- `~MessageComponent()`：析构函数，释放 `_pCallBackFuns` 指针。
- `AwakeFromPool(IMessageCallBackFunction* pCallback)`：从对象池唤醒时的初始化。
- `BackToPool()`：返回对象池时的清理。
- `IsFollowMsgId(Packet* packet) const`：判断是否关注特定的消息ID。
- `ProcessPacket(Packet* packet) const`：处理消息包。

### Packet

`Packet` 类是消息包的封装，包含消息的数据和元信息。它的主要功能是封装消息数据，并提供序列化和反序列化的方法。

## IMessageCallBackFunction

`IMessageCallBackFunction` 是一个接口类，定义了消息回调函数的接口。具体的消息处理逻辑由实现该接口的类来完成。该接口通常包含以下两个方法：

1. **IsFollowMsgId**：判断组件是否关注特定的消息ID。
2. **ProcessPacket**：处理消息包。

这个接口的实现类需要根据具体的业务逻辑来处理不同类型的消息包。

## 组件关系与工作流程

1. **消息的创建和分发**：
   - 使用 `MessageSystemHelp` 类的静态方法 `CreatePacket` 创建一个新的消息包 `Packet`。
   - 使用 `MessageSystemHelp` 类的静态方法 `DispatchPacket` 分发消息包。消息包会被添加到 `MessageSystem` 的待处理列表中。

2. **消息的处理**：
   - `MessageSystem` 类的 `Update` 方法会定期调用，用于处理所有待处理的消息包。
   - `Update` 方法首先检查缓存交换器 `_cachePackets` 是否可以交换，如果可以，则交换读写缓存。
   - 从 `EntitySystem` 获取所有 `MessageComponent` 组件的集合。
   - 对于每个待处理的消息包，调用 `MessageSystem` 的静态方法 `Process`，将消息包分发给所有 `MessageComponent` 组件。
   - 每个 `MessageComponent` 组件调用其内部的回调函数 `IMessageCallBackFunction` 来处理消息包。

3. **消息的发送**：
   - 使用 `MessageSystemHelp` 类的静态方法 `SendPacket` 发送消息包。根据当前应用类型和目标应用类型，消息包可能会被直接分发或者通过网络发送到其他进程。
   - 如果目标应用类型与当前应用类型匹配，则直接调用 `DispatchPacket` 方法分发消息包。
   - 如果目标应用类型与当前应用类型不匹配，则通过 `NetworkLocator` 获取网络连接器，将消息包发送到目标应用。


## 线程间消息通信的实现

1. **消息创建**：
   - 在一个线程中，使用 `MessageSystemHelp` 类的静态方法 `CreatePacket` 创建一个新的消息包 `Packet`。
   - 这个消息包可以包含需要传递的数据和元信息（如消息ID和套接字）。

2. **消息分发**：
   - 使用 `MessageSystemHelp` 类的静态方法 `DispatchPacket` 将消息包分发到 `MessageSystem`。
   - `MessageSystem` 将消息包添加到其内部的待处理列表 `_cachePackets` 中。这个操作通常在消息发送线程中完成。

3. **消息处理**：
   - `MessageSystem` 的 `Update` 方法会在一个独立的处理线程中定期调用。
   - `Update` 方法首先检查缓存交换器 `_cachePackets` 是否可以交换，如果可以，则交换读写缓存。这种设计确保了线程安全，避免了多个线程同时访问同一个消息列表。
   - `Update` 方法从 `EntitySystem` 获取所有 `MessageComponent` 组件的集合，并将消息包分发给这些组件。
   - 每个 `MessageComponent` 组件通过其内部的回调函数 `IMessageCallBackFunction` 来处理消息包。

4. **消息发送**：
   - 使用 `MessageSystemHelp` 类的静态方法 `SendPacket` 发送消息包。根据当前应用类型和目标应用类型，消息包可能会被直接分发或者通过网络发送到其他进程。
   - 如果目标应用类型与当前应用类型匹配，则直接调用 `DispatchPacket` 方法分发消息包。
   - 如果目标应用类型与当前应用类型不匹配，则通过 `NetworkLocator` 获取网络连接器，将消息包发送到目标应用。

### 线程间通信的优势

1. **线程安全**：
   - 使用互斥锁 `_packet_lock` 确保对待处理消息包列表的操作是线程安全的。
   - 缓存交换器 `_cachePackets` 的设计确保了读写缓存的分离，避免了多个线程同时访问同一个消息列表，进一步提高了线程安全性。

2. **灵活性和扩展性**：
   - `MessageSystem` 可以处理不同类型的消息包，只需在 `MessageComponent` 中实现相应的回调函数 `IMessageCallBackFunction` 即可。
   - 系统的模块化设计使得各个组件之间的耦合度较低，可以根据需要进行扩展和修改。

3. **高效性**：
   - 缓存交换器 `_cachePackets` 的设计使得消息处理可以批量进行，减少了锁竞争，提高了处理效率。
   - `MessageSystemHelp` 提供的辅助方法简化了消息的创建、分发和发送，提高了开发效率。

4. **跨进程通信**：
   - 通过 `NetworkLocator` 和网络连接器，系统可以实现跨进程的消息传递，适用于分布式系统。

### 代码示例：线程间消息通信

以下是一个简单的示例，展示如何在两个线程之间创建、分发和处理消息包。

#### 线程A：消息创建和分发

```cpp
#include <thread>
#include "message_system_help.h"
#include "packet.h"

void ThreadAFunction()
{
    // 创建消息包
    Proto::MsgId msgId = ...; // 消息ID
    SOCKET socket = ...; // 套接字
    auto packet = MessageSystemHelp::CreatePacket(msgId, socket);

    // 分发消息包
    MessageSystemHelp::DispatchPacket(packet);

    // 其他逻辑...
}

std::thread threadA(ThreadAFunction);
```

#### 线程B：消息处理

```cpp
#include <thread>
#include "message_system.h"
#include "entity_system.h"

void ThreadBFunction(MessageSystem* messageSystem, EntitySystem* entitySystem)
{
    while (true)
    {
        // 更新消息系统，处理所有待处理的消息包
        messageSystem->Update(entitySystem);

        // 其他逻辑...

        // 休眠一段时间，避免占用过多CPU资源
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

MessageSystem* messageSystem = new MessageSystem(systemManager);
EntitySystem* entitySystem = new EntitySystem();
std::thread threadB(ThreadBFunction, messageSystem, entitySystem);
```

这个消息队列系统设计用于在多线程环境中安全高效地传递和处理消息。通过 `MessageSystem`、`MessageSystemHelp`、`MessageComponent` 等组件的协作，实现了线程间的消息通信。系统的设计考虑了线程安全、灵活性、高效性和跨进程通信，适用于各种复杂的消息传递和处理场景。






### 代码示例

#### 创建并分发消息包
```cpp
Proto::MsgId msgId = ...; // 消息ID
SOCKET socket = ...; // 套接字
auto packet = MessageSystemHelp::CreatePacket(msgId, socket);
MessageSystemHelp::DispatchPacket(packet);
```

#### 创建并发送消息包
```cpp
Proto::MsgId msgId = ...; // 消息ID
SOCKET socket = ...; // 套接字
google::protobuf::Message proto = ...; // Protobuf 消息
MessageSystemHelp::SendPacket(msgId, socket, proto);
```

#### 从对象池唤醒消息组件并处理消息包
```cpp
IMessageCallBackFunction* callback = ...; // 回调函数
auto messageComponent = new MessageComponent();
messageComponent->AwakeFromPool(callback);

Packet* packet = ...; // 消息包
if (messageComponent->IsFollowMsgId(packet))
{
    messageComponent->ProcessPacket(packet);
}
```

### 总结

这个消息队列系统通过 `MessageSystem` 统一管理消息包的创建、分发和处理。`MessageSystemHelp` 类提供了一些辅助方法，简化了消息包的创建和分发。`MessageComponent` 负责具体的消息处理逻辑，通过回调函数 `IMessageCallBackFunction` 实现具体的业务逻辑。整个系统设计模块化、灵活，可用于处理各种复杂的消息传递和处理场景。